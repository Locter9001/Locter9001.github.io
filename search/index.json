[{"content":"计算机网络 计算机网络的分类 按交换技术分类 电路交换网络 报文交换网络 交换机只有在接收完报文之后才会进行转发\n分组交换网络 将数据分组逐步转发，各分组可以由不同链路转发。\n按使用者分类 公用网 专用网 按传输介质分类 有线网络 无线网络 按覆盖范围分类 广域网 WAN 因特网核心，覆盖范围极广，可横跨国家乃至州\n城域网 MAN 城市骨干网\n局域网 LAN 一般用微型计算机或工作站通过高速通信线路相连，速率通常在10Mbit/s 范围较小\n个域网 PAN 个人使用的网络，如智能手表，无线耳机，无线鼠标键盘等，覆盖范围大约为十米\n按拓扑结构分类 总线型网络 使用单根传输线把计算机连接起来，\n优点：是建网容易，增减节点方便，节省线路\n缺点：重负载时通信效率不高，总线任意一处出现故障，则全网瘫痪\n星型网络 将每个计算机都以单独的线路与中央设备相连，中央设备早期是计算机，后来是集线器，现在一般是交换机或路由器\n优点：便于网络集中控制和管理\n缺点：成本高，中央设备对故障敏感\n环形网络 将所有计算机的网络接口连接成一个环，详见令牌环局域网，环可以是单环也可以是双环，环中信号是单向传输。\n网状型网络 一般情况下，每个节点至少由两条路径与其他节点相连，多用在广域网(WAN)中\n优点：可靠性高\n缺点：控制复杂，线路成本高\n计算机网络的性能指标 比特 bit bit 是数据量的单位\n常用数据量单位：\n8bit = 1Byte = 1字节\nKB = 2¹⁰ B\nMB = K · KB = 2¹⁰ · 2¹⁰ B = 2²⁰ B\nGB = K · MB = 2¹⁰ · 2²⁰ B = 2³⁰ B\n速率 常用单位： bit/s (b/s, bps)\n带宽 带宽在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围；\n单位： Hz（kHz，MHz，GHz）\n带宽在计算机网络中的意义 用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”；\n单位： b/s （kb/s，Mb/s，Gb/s，Tb/s）\n“带宽” 的这两种表述之间有着密切的联系，一条通信线路的“频带宽度” 越宽，其所传输数据的“最高数据率”也越高\n吞吐量 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量\n吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络\n吞吐量受网络带宽或额定速率的限制\n时延 发送时延 数据在发送时的延迟\n计算公式：分组长度（b）/ 发送速率（b/s）\n传播时延 数据传播到各节点或终点时的延迟\n计算公式：信道长度（m）/\t电磁波传播速率（m/s）\n电磁波传播速率常用导体：\n自由空间： 3 * 10⁸ m/s\n铜线：2.3 * 10⁸ m/s\n光纤：2.0 * 10⁸ m/s\n处理时延 数据到达各节点并转发处理时的延迟，不方便计算具体延迟\n小结 报文交换总时间 = 报文的发送时延 * 链路\n分组交换总时间 = 报文的发送时延 * 1个分组的发送时延\n时延带宽积 时延带宽积 = 传播时延 * 带宽\n若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特；\n链路的时延带宽积又称为以比特为单位的链路长度\n往返时间 在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互；\n我们有时很需要知道双向交互一次所需的时间；\n因此，往返时间RTT（round-trip time）也是一个重要的性能指标\n利用率 利用率分 信道利用率和网络利用率两种\n信道利用率：用来表示某信道有百分之几的时间是被利用的（有数据通过）。\n网络利用率: 全网络的信道利用率的加权平均\n  根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加；\n  因此，信道利用率并非越高越好；\n  如果令 D0 表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D、D0和利用率U之间的关系：\n​\tD = D0 / 1-U ；\n 当网络利用率到达 50%时，时延就要加倍； 当网络利用率超过 50%时，时延急剧增大； 当网络利用率接近 100%时，时延就趋于无穷大； 因此，一些拥有较大主干网的ISP通常会控制它们的信道利用率不超过50%，如果超过了，就要准备扩容，增大线路的带宽。    也不能是信道利用率太低，这会使宝贵的通信资源被白白浪费。应该使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在一个合理的范围内\n  丢包率   丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。\n  丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。\n  丢包率时网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。\n  分组丢失主要有两种情况\n  分组在传输过程中出现误码，被节点丢弃；\n  分组到达一台队列已满的分组交换机时被丢弃；\n在通信量较大时就可能造成网络拥塞。\n    因此，丢包率反应了网络的拥塞情况：\n 无拥塞时路径丢包率为0% 轻度拥塞时路径丢包率为 1% ~ 4% 严重拥塞时路径丢包率为 5% ~ 15%    计算机网络体系结构 常见的计算机网络体系结构 OSI体系结构 是法律上的国际标准，不可靠！\nTCP/IP 体系结构 事实上的国际标准 生活中经常使用的\nIP协议直接为ICMP协议提供服务\nPPP协议属于TCP/IP体系结构网络接口层，它可以直接为IP协议提供服务。\n原理体系结构 结合上述体系的优点 适合教学\n计算机网络体系结构分层的必要性 1.物理层 ​\t解决使用何种信号来传输比特的问题\n2.数据链路层 ​\t解决分组在一个网络（或一段链路）上传输的问题\n3.网络层 ​\t解决分组在多个网络上传输（路由）的问题\n4.运输层 ​\t解决进程之间基于网络的通信问题\n5.应用层 ​\t解决通过应用进程的交互来实现特定网络应用的问题\n计算机网络体系结构中的专用术语 实体 任何可发送或接收信息的硬件或软件进程。\n对等实体 收发双方相同层次中的实体。\n协议 控制两个对等实体进行逻辑通信的规则的集合。\n协议的三要素\n 语法 定义所交换信息的格式 语义 定义收发双方所要完成的操作 同步 定义收发双方的时序关系  服务 在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务\n 要实现本层协议，还需要使用下面一层所提供的服务 协议是 “水平的”，服务是 “垂直的”。 实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议，也就是说，下面的协议对上面的实体是透明的。  服务访问点 在同一系统中相邻两层实体交换信息的逻辑接口，用于区分不同的服务类型。\n服务原语 上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。\n协议数据单元PDU 对等层次之间传输的数据包称为该层的协议数据单元。\n服务数据单元SDU 同一系统内，层与层之间交换的数据包称为服务数据单元。\n物理层 物理层的基本概念 ​\t解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务。所谓透明是指数据链路层看不见也无需看见物理层究竟使用的是什么方法来传输比特0和1的。只管享受物理层提供的比特流传输服务即可。\n重点：\n 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层协议和服务，而不必考虑网络具体的传输媒体是什么。  物理层为了解决在各种传输媒体上传输比特0和1的问题，主要有以下四个任务：\n  机械特性：\n​\t指明接口所用的接线器的形状和尺寸，引脚数目和排列，固定和锁定装置。\n  电气特性：\n​\t指明在接口电缆的各条线上出现的电压的范围。\n  功能特性：\n​\t指明某条线上出现的某一电平的电压表示何种意义。\n  过程特性：\n​\t指明对于不同功能的各种可能的事件的出现顺序。\n  （ 由于传输媒体的种类众多，例如双绞线、光纤等。物理连接方式也很多，例如点对点连接、广播连接等。因此物理层协议种类就比较多，每种物理层协议都包含了上述四个任务的具体内容 ）\n导引型传输媒体 同轴电缆 基带同轴电缆（50Ω）：数字传输，过去用于局域网。\n宽带同轴电缆（75Ω）：模拟传输，目前主要用于有线电视。\n双绞线 光纤 电力线 最早的的方式\n非导引型传输媒体 无线电波 微波 列如使用 2.4GHz 和 5.8GHz 频段的WI-FI\n红外线 点对点无线传输\n直线传输，中间不能有障碍物，传输距离短\n传输速率低（4Mb/s~16Mb/s）\n可见光 通过高速调制光的开关来通讯\n传输方式 串行传输 \u0026amp;\u0026amp; 并行传输 串行传输 一个比特一个比特的传输数据\n并行传输 一次发送n个比特而不是一个比特，因此在发送端和接收端之间需要有n条线路\n例如硬件里的CPU和内存\n同步传输 \u0026amp;\u0026amp; 异步传输 同步传输 数据块以稳定的比特流的形式传输，字节之间没有间隔。\n接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1.\n异步传输 以字节为独立的传输单位，字节之间的时间间隔不是固定的。接收端仅在每个字节的起始处对字节内的比特实现同步，为此 通常要在每个字节前后分别加上起始位和结束位。\n单工 \u0026amp;\u0026amp; 半双工 \u0026amp;\u0026amp; 全双工 单工 又称为单向通信，只需要一条信道。\n通信双方只有一个数据传输方向，例如无线电广播就是采用这种方式。\n半双工 又称为双向交替通信，需要两条信道，一条接收一条发送。\n通信双方可以相互传输数据，但不能同时进行。例如对讲机就是采用这种方式。\n全双工 又称为双向同时通信，需要两条信道，一条接收一条发送。\n通信双方可以同时发送和接收信息。例如电话采用的就是这种方式。\n编码与调制 常用编码 不归零编码（存在同步问题）\n又称不归零编码NRZ：\n1.整个码元事件内电平不发生变化\n2.需要额外的传输线来传输时钟信号\n归零编码 （自同步，编码效率低）\n又称归零编码RZ：\n每个马原传输结束后信号都要 “ 归零 ”，所以接收方只需要在信号归零后进行采样即可。\n曼彻斯特编码（传统以太网，10Mb/s）\n1.码元中间时刻的跳变即表示时钟，又表示时间。\n2.正/负 跳变表示1/0可以自行定义。\n差分曼彻斯特编码（比曼彻斯特编码变化少，更适合较高的传输速率）\n1.跳变仅表示时钟。\n2.马原开始处电平是否发生变化表示数据，发生变化表示0，不发生变化表示1。\n（小知识： log₂ N\t可得出每个码元可以携带的比特量\t|\tN ： 相位数）\n调制 基本调制方法 使用基本调制方法，一个码元只能包含一个比特信息\n混合调制方法 信道的极限容量 奈氏准则 在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的。\n理想低通信道的最高码元传输速率 = 2W Baud = 2W 码元/秒\n理想带通信道的最高码元传输速率 = W Baud\t= W 码元/秒\n​\tW : 信道宽带（单位为Hz）\n​\tBaud : 波特，即码元/秒\n码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系：\n 当一个码元只携带1比特的信息量时，则波特率（码元/秒）与比特率（比特/秒）在数值上是相等的； 当一个码元携带n比特的信息量时，则波特率转换成比特率时，数值要乘以n。  要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。\n（考点注意：若没有指明信道频率的上下限，则该信道属于低通信道）\n实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。\n香农公式 小知识： log₂8 == 2的多少次方等于8，答案是3次方 2×2×2 = 8\n带宽受限且由高斯白噪声干扰的信道的极限信息传输速率。\n公式： c = W * log₂（1 +S/N）\nc ： 信道的极限信息传输速率（单位：b/s）\nW : 信道带宽 （单位：Hz）\nS : 信道内所传信号的平均功率\nN : 信道内的高斯噪声功率\nS/N :\t信噪比，使用分贝（dB）作为度量单位\n​\t信噪比（dB）= 10 * log₁₀（S/N）\t（dB）\n信道带宽或信道中信噪比越大，信息的极限传输速率越高。\n在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少，这是因为在实际信道中，信号还要受到其他的一些损伤，如各种脉冲干扰、信号在传输中的衰减和失真等，这些因素在香农公式中并未考虑。\n综合 在信道宽带一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制（更好的调制方式）和努力提高信道中的信噪比。\n自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地接近香农公式给出的传输速率极限。\n数据链路层 概述 又可以看成是：\n 链路（Link）就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。 数据链路（Data Link）是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。 数据链路层以 帧 为单位传输和处理数据  使用点对点信道的数据链路层\n 三个重要问提：封装成帧、差错检测、可靠传输  使用广播信道的数据链路层\n 共享式以太网的媒体接入控制协议CSMA/CD 802.11局域网的媒体接入控制协议CSMA/CA  数据链路层的互联设备\n 网桥和交换机的工作原理 集线器（物理层互联设备）与交换机的区别  封装成帧 封装成帧 是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧\n如下图所示：\n帧头和帧尾中包含有重要的控制信息。\n例如以太网版本2的MAC帧格式，如图：\n点对点协议PPP帧格式：\n发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层将构成帧的各比特转换成点型号发送到传输媒体。\n 问题：接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？\n答：\t使用帧定界\n帧头和帧尾的作用之一就是帧定界\n点对点协议PPP帧格式中的1字节的标志就是帧定界，假设发送方发送的是PPP帧，比特流中红色部分是帧定界标志！（1字节 == 1B == 1byte == 8bit） 01111110 就是帧标志\n但并不是每个协议都有帧定界标志！例如以太网V2的MAC帧就没有帧头和帧尾标志，但是以太网的数据链路层封装好MAC帧后，将其交付给物理层，物理层会在MAC帧前面添加8字节的前导码。然后再将比特流装换成电信号发送。前导码中的前7个字节为前同步码，作用是使接收方的时钟同步，之后的1字节为帧开始定界符，表明其后面紧跟着的就是MAC帧。如下图所示：\n另外，以太网还规定了帧间间隔时间为96比特的发送时间。因此，MAC帧并不需要帧结束定界符。帧间间隔还有其他作用\n 透明传输 是指 数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样\n（数据链路层对上层交付的协议数据单元有限制，其内容不能包含帧定界符。但是各种数据链路层协议会想办法解决其中包含的帧定界符，例如在发送帧之前，对帧的数据部分进行扫描，将帧定界符转义来实现透明传输）\n1 2 3 4 5 6 7 8 9 10 11 12 13  int main(){ //以下代码是假设！不管代码对错是否能运行，理解就好  cout \u0026lt;\u0026lt; 1011001101 click() 100011 \u0026lt;\u0026lt; endl; //\t上述代码会报错，找不到click()函数，但是我们只想打印出 click() 这个文本  //\t所以需要用 \u0026#39;\u0026#39; 引号 来将 click() 转换成文本 如下：  cout \u0026lt;\u0026lt; \u0026#39;click()\u0026#39; \u0026lt;\u0026lt; endl; //\t现在不会报错了，就如同这个例子一样。比特流中也不能包含关键字（帧定界符）  //\t所以需要用类似的方式进行转义！ } int click(){ return 01111110 //\t可以将此函数比喻为帧定界符 }   面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输。\n面向比特的物理链路使用比特填充的方法实现透明传输。\n1 2 3  int main(){ cout \u0026lt;\u0026lt; \u0026#39;hello world\u0026#39; \u0026lt;\u0026lt; endl; }   为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。\n考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU（Maximum Transfer Unit）\n差错检测 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，0可能会变成1。这称为 比特差错\n在一段时间内，传输错误的比特占所传输的比特总数的比特称为 误码率BER（Bit Error Rate）。\n使用 差错检测码 来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一\n差错码 只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此 无法纠正错误。\n要想纠正传输中的差错，可以使用冗余信息更多的 纠错码 进行 前向纠错。但纠错码的开销比较大，在 计算机网络中较少使用。\n循环冗余检验 CRC 有很好的检错能力（漏检率非常低），虽然计算比较复杂，但非常 易于用硬件实现，因此被 广泛应用于数据链路层。\n在计算机网络中通常采用 检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务\n奇偶校验 ​\t在待发送的数据后面 添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中 **“ 1 “ 的个数 **为奇数（奇校验）或偶数（偶校验）。\n 如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码； 如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码（漏检）；  奇偶校验法的漏检率过高，在计算机网络的数据链路层一般不会采用该方法\n循环冗余校验CRC（Cyclic Redundancy Check）   收发双方约定好一个 生成多项式 G(x);\n  发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到待传输数据的后面一起传输；\n  接收方通过生成多项式来计算收到的数据是否产生了误码；\n  使用这些生成多项式进行CRC校验，可以达到较好的检错效果，也就是漏检率比较低\nCRC算法要求生成多项式必须包含最低次项。\n异或运算：\n【循环冗余检验CRC举例】待发送的信息为101001，生成多项式为G(x) = x³ + x² + 1 , 计算余数。\n第一步：构造被除数\n待发送信息后面添加生成多项式最高次数个0\t生成多项式中最高次数是x³ 则添加三个0\n得：101001000\n第二步：构造除数\n生成多项式各项系数构成的比特串，\nG(x) = x³ + x² + 1 还原后得 G(x) = 1·x³ + 1·x² + 0·x¹ + 1·x⁰ ，将系数组合成串得：1101\n第三步：做除法\n商中从左到右第一个数字标记为1表示是从这里开始的，其他的表示是否够除，0表示不够除，1表示够除。\n第四步：检查余数\n余数的位数应与生成多项式最高次数相同，如果位数不够，则在余数前补0来凑足位数。上图中补了两个0\n将余数添加到带发送信息的后面就可以发送了，”101001“ + ”001“ == ”101001001“\n【循环冗余检验CRC举例】接收到的信息为101101001，生成多项式为G(x) = x³ + x² + 1 ,判断传输是否误码？\n​\t答案：余数为11，有误码。过程自己算算看\n可靠传输 基本概念 可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。\n​\t一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。\n​\t无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。\n比特差错只是传输差错中的一种。（此处将帧的称呼改为了分组）\n从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复。\n分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。因此可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输\n可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求。\n可靠传输的三种实现机制 这三种可靠传输实现机制的基本原理并不局限于数据链路层，可以应用到计算机网络体系结构的各层协议中。\n停止-等待协议SW 确认与否认 发送方给接收方发送数据分组，接收方进行 差错检测 判断该数据分组是否有误码\n  若没有误码，则接收该分组，并给发送方发送确认分组ACK\n  若有误码，则丢弃该数据分组，并给发送方发送否认分组NAK。发送方接收NAK后立刻重传该数据分组。\n  （因此发送方每发送完一个数据分组后并不能立刻将该数据分组从缓存中删除，只有收到ACK确认分组后才可以删除）\n发送方每发送完一个数据分组后，就停止发送下一个数据分组，收到ACK确认分组或者NAK否认分组才能进行下一步操作。\n超时重传 假设发送方在发送数据分组的过程中意外丢失了该数据分组，接收方没有收到该分组，发送端也没有收到任何确认或重传指令所以不会发送下一个数据分组。为避免这类事件的发生，可以在发送端添加一个超时计时器，超过一定时间后仍未收到ACK或NAK指令，则重发该数据分组。\n确认丢失 假设接收端收到数据后发送的确认分组ACK在发送途中意外丢失，而接收端的超时计时器触发使上一个数据分组重复发送。为避免这类事件，可以给发送端发送的数据分组编号，由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。接收端收到数据分组后发现与上一个收到的数据分组编号一样便丢弃该分组，向发送端发送确认分组ACK。\n确认迟到 若接收端的确认分组ACK因为某些原因延迟到达发送端，发送端重发数据分组后又发送了下一个数据分组，接收端收到重复的数据分组和下一个数据分组后向发送端发送了两个确认分组ACK,为了避免这类事件，可给确认分组ACK进行编号，所用比特数量与数据分组编号所用的比特数据量一样。发送端收到同样编号的确认分组ACK后会忽略该确认分组\n【注意事项】\n 接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。 为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。 为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号。所用比特数量与数据分组编号所用的比特数据量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。 超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于 “ 从发送方到接收方的平均往返时间 ”。  在数据链路层点对点的往返时间比较确定，重传时间比较好设定。 然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。    停止-等待协议SW信道利用率 Td： 发送方发送数据分组所耗费的发送时延 Time Data\nRTT ：收发双方之间的往返时间\nTa： 接收方发送确认分组所耗费的发送时延 Time Ack\n图中忽略了接收方对数据分组的处理时延以及发送方对确认分组的处理时延。\nTa远小于 Td可以忽略，当 RTT 远大于 Td时，信道利用率会非常低。\n【举例】假设信道长度2000km，数据分组长度1500B，发送速率10Mbit/s。\n（忽略Ta，因为Ta一般都远小于Td）\n答：\n​\t根据发送时延 = 分组长度（b）/ 发送速率（b/s）\n​\t可得出 1500 / 1250,000 = 0.0012s = 1.2ms\n​\t根据传播时延 = 信道长度（m）/\t电磁波传播速率（m/s）\n​\t（为了方便计算使用光纤的传播速度： 2 * 108m/s）\n​\t可得出 2,000,000 / 3 * 108= 0.01 = 10ms\n​\t因为是往返时间所以 10 * 2 得 20ms\n​\t1.2 / 21.2 = 0.056\u0026hellip;\t0.056 * 100 = 5.66%\n【举例】主机甲采用停-等协议向主机乙发送数据，数据传输速率是3kbps，单向传播延时是200ms，忽略确认帧的传输延时。当信道利用率等于40%时，数据帧的长度为多少？\n答案：800比特，过程自己算\n 若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。 为了克服停止-等待SW协议信道利用率很低的缺点，就产生了另外两种协议，即 **后退N帧协议GBN **和 选择重传协议SR。 像停止-等待协议这种通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ（Automatic Repeat reQuest）意思是重传的请求是自动进行的。  回退N帧协议GBN 跟SW协议差不多，只是发送方一次连续发送N个帧，而接受方正确有序接收N个帧后\n才会发送 N [N - 1] 个 ACK\n回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议。\n在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议。\n由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比SW协议高。\n选择重传协议SR 为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸 WR不应再等于 1 （而应大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。\nSR协议为了使发送方仅重传出现差错的分组，接收方不能再采用累计确认，而需要对每个正确接收到的数据分组进行逐一确认！\n点对点协议PPP 点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议。也广泛运用于广域网路由器之间的专用线路。\nPPP协议是因特网工程任务组IETF在1992年制定的。经过1992年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]。\nPPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：\n 对各种协议数据报的封装方法（封装成帧） 链路控制协议LCP，用于建立、配置以及测试数据链路的连接 一套网络控制协议NCPs，其中的每一个协议支持不同的网络层协议  PPP协议帧格式： 1 2  16进制以0x开头，后面跟数字0~9或字母A~F（小写也可以）， 如：0x2D（16进制数2D）   PPP协议解决透明传输问题 如果帧的数据部分有标志字段F（定界符），那么该怎么让接收方忽略该标志字段呢？\nPPP协议实现透明传输的方法取决于所使用的链路类型\n**面向字节的异步链路：**采用字节填充法，也就是插入转义字符。\n  发送方的处理：\n 出现的每一个7E（PPP帧的定界符）字节转变成2字节序列（7D，5E）  相当于在7E字节前插入了转义字符7D，并将7E字节减去16进制的20。   出现的每一个7D（转义字符）字节转变成2字节序列（7D，5D）  相当于在7D字节前插入了转义字符7D，并将7D字节减去16进制的20。   出现的每一个ASCII码控制字符（数值小于0x20的字符），则在该字符前面插入一个7D字节，同时将该字符的编码加上0x20。    接收方的处理：\n 进行反变换即可恢复出原来的帧的数据部分。    **面向比特的同步链路：**则采用比特填充法，也就是插入比特0。\n帧定界符 =\u0026gt; 01111110\n  发送方的处理\n 对帧的数据部分进行扫描（一般由硬件实现）。只要发现5个连续的比特1，则立即填充1个比特0。    接收方的处理\n 对帧的数据部分进行扫描（一般由硬件实现）。只要发现5个连续的比特1，就把其后的1个比特0删除。    差错检测 工作状态 媒体介入控制的基本概念 静态划分信道 信道复用 计算机网络微课堂（有字幕无背景音乐版）_哔哩哔哩\n简单理解：\n 复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。 多址（更确切的应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道地应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户地应用中，多址是不需要的（对于无线广播或电视广播站就是这样）。 某种程度上，FDMA、TDMA、CDMA可以分别看成FDM、TDM、CDM地应用。  常见的复用技术有\n频分复用FDM、时分复用TDM、波分复用WDM、码分复用CDM\n频分复用FDM 的所有用户同时占用不同的频带资源并通信。\n​\t（广播的频率有很多 就如同一个用户用高频分段，另一个用户用低频分段）\n时分复用TDM 的所有用户在不同的时间占用同样的频带宽度。时分复用技术将时间划分成一段段登场的时分复用帧。每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙。\n波分复用WDM 就是光（光纤）的频分复用，具体网上搜吧~\n码分复用CDM：\n  码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用名词是码分多址CDMA（Code Division Multiple Access）。\n  同理，频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是频分多址FDMA（Frequency Division Multiple Access）和时分多址TDMA（Time Division Multiple Access）。\n  与FDM和TMD不同，CDM的每一个用户可以 在同样的时间使用同样的频带进行通信。\n  由于 各用户使用经过特殊挑选的不同码型，因此各用户之间 不会造成干扰。\n  CDM最初用于军事通信，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于白噪声不易敌人被发现。\n  随着技术的进步，CDMA设备的价格和体积都大幅度下降，因而现在已广泛用于民用的移动通信中。\n  在CDMA中，每一个比特时间再划分为m各短的间隔，称为码片（Chip）。通常m的值是64或128。为了简单起见，在后续的举例中，我们假设m为8。\n  使用CDMA的每一个站被指派一个唯一的 m bit码片序列（Chip Sequence）。\n 一个站如果要发送比特1，则发送它自己的 m bit码片序列； 一个站如果要发送比特0，则发送它自己的 m bit码片序列的二进制反码；  【举例】\n​\t指派给CDMA系统中某个站点的码片序列为00011011\n​\t发送比特1：发送自己的码片序列 00011011\n​\t发送比特0：发送自己的码片序列的二进制反码 11100100\n（这种通信方式称为直接序列扩频DSSS）\n  码片序列的挑选原则如下：\n  分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。\n  分配给每个站的码片序列必须相互正交（规格化内积为0）。\n令向量S表示站S的码片序列，令向量T表示其他任何站的码片序列。\n两个不同站S和T的码片序列正交，就是向量S和T的规格化内积为0：\n​\t​\t∑：求和符号保姆级教学！哔哩哔哩\n    【习题】假设给站S分配的码片序号为01011101，给站T分配的码片序号为10111000，这样分配正确吗？（为了简单起见，我们假设m为8）\n答：\n​\t1. S码片序列和T码片序列符合码片序列的挑选原则[1]\n​\t2. 向量S和T的规格化内积不为0，不符合码片序列的挑选原则[2]\n故这样分配不正确！\n动态接入控制 总线局域网使用的CSMA/CD协议 计算机网络微课堂（有字幕无背景音乐版）_哔哩哔哩\n载波监听多址接入/碰撞检测 CSMA/CD（Carrier Sense Multiple Access / Collision Detection）\n无线局域网使用的CSMA/CA协议 载波监听多址接入/碰撞避免 CSMA/CA（Carrier Sense Multiple Access / Collision Avoidance）\n在无线局域网中，仍然可以使用载波监听多址接入CSMA，即再发送帧之前先对传输媒体进行载波监听。若发现有其他站再发送帧，就推迟发送以免发生碰撞。\n在无线局域网中，不能使用碰撞检测CD，原因如下：\n 由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高。 即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性**（存在隐蔽站问题），进行碰撞检测的意义也不大**。如图所示：    802.11无线局域网使用CSMA/CA协议，在CSMA的基础上增加了一个碰撞避免CA功能，而不再实现碰撞检测功能。\n  由于不可能避免所有的碰撞，并且无线信道误码率较高，802.11标准还使用了**数据链路层确认机制（停止-等待协议）**来保证数据被正确接收。\n  802.11的MAC层标准定义了两种不同的媒体接入控制方式：\n 分布式协调功能DCF（Distributed Coordination Function）。在DCF方式下，没有中心控制站点，每个站点使用CSMA/CA协议通过征用信道来获取发送权，这是802.11定义的默认方式。 点协调功能PCF（Point Coordination Function）。PCF方式使用集中控制的接入算法（一般在接入点AP实现集中控制），802.11定义的可选方式，在实际中较少使用。    802.11标准规定，所有的站点必须在持续监测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔IFS（Inter Frame Space）。\n  帧间间隔的长短取决于该站点要发送的帧的类型：\n 高优先级帧需要等待的时间较短，因此可优先获得发送权； 低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。    常见的两种帧间间隔如下：\n 短帧间间隔SIFS（28μs）,是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。 DCF帧间间隔DIFS（128μs），它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧。    CSMA/CA协议的工作原理 CSMA/CA协议的退避算法\n在执行退避算法时，站点为退避计时器设置一个随机的退避时间：\n 当退避计时器的时间减小到零时，就开始发送数据； 当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。  在进行第 i 次退避时，退避时间在时隙编号{0，1，\u0026hellip;，22 + i -1}中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避）就不再增加了。\n 当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法。 以下情况必须使用退避算法：  在发送数据帧之前检测到信道处于忙状态时； 在每一次重传一个数据帧时； 在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）；    CSMA/CA协议的信道预约和虚拟载波监听 为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据的站点对信道进行预约。\n（1）源站再发送数据帧之前先发送一个短的控制帧，称为请求发送RTS（Request To Send），它包括源地址、目的地址以及这次通信（包括相应的确认帧）所需的持续时间。\n（2）若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS（Clear To Send），他也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS帧中）。\n（3）源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。\n（4）若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。\n除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。\n如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧。\n由于RTS帧和CTS帧很短，发送碰撞的概率，碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就越多，因此用很小的代价对信道进行预约往往是最值得的。802.11标准规定了3钟情况供用户选择：\n 使用RTS帧和CTS帧 另一种是不使用RTS帧和CTS帧 只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧  除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制。\n由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题。\nMAC地址、IP地址、ARP协议 MAC地址是以太网的MAC子层所使用的地址；（属于数据链路层的范畴）\nIP地址是TCP/IP体系结构网际层所使用的地址；\nARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址；\n尽管IP地址和ARP协议属于TCP/IP体系结构的网际层（而不属于数据链路层），但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。因此我们将这三者放在一起讨论\nMAC地址 MAC地址是以太网的MAC子层所使用的地址；（属于数据链路层的范畴）\n使用点对点信道的数据链路层不需要使用地址，\n而使用广播信道的数据链路层必须使用地址来区分各主机，也就是说当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址；\n在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC（Media Access Control），因此这类地址被称为MAC地址；\n MAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读储存器EEPROM中，因此MAC地址也被称为硬件地址； MAC地址有时被称为物理地址。但这并不意味着MAC地址属于网络体系结构中的物理层！  一般情况下，用户主机会包括两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。\nIEEE 802局域网的MAC地址格式 由48个比特构成，每8个比特为1个字节，从左至右依次为第一字节到第六字节。\n前三个字节是组织唯一标识符OUI，由IEEE的注册管理机构分配。\n后三个字节是网络接口标识符，由获得OUI的厂商自行随意分配。\n这种地址标识符称为扩展的唯一标识符EUI，对于48比特的MAC地址，可称为EUI-48。\nMAC地址的标准表示方法是将每4个比特写成一个16进制的字符，共12个字符，将每两个字符分成一组，共6租\n（可以在IEEE的官方网站查看已分配的OUI，www.standards-oui.ieee.org/oui.txt）\n对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代。\nMAC地址的发送顺序：\n字节发送顺序： 第一字节 到 第六字节\n字节内的比特发送顺序：b0 =\u0026gt; b7\n单播MAC地址举例：\n简单理解：单播就是给一个目的地发送信息\n假设有ABC三个主机\n主机B要给主机C发送信息，首先要构建该单播帧，在帧首部中的目的地址字段，填入C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段， 数据载荷以及帧尾部就构成了单播帧，发送方将该单播帧发送出去后，主机A和C都会接收到该单播帧，主机A的网卡发现该单播帧的目的MAC地址与自己的MAC地址不匹配，于是丢弃该帧。而主机C的网卡发现该单播帧的目的MAC地址于自己的MAC地址相匹配便接收该帧，并将该帧交给上层处理。。\n广播MAC地址举例：\n简单理解：广播就是给所有目的地发送信息（范围内）\n假设有ABC三个主机\n主机B要发送广播帧，首先要构建该广播帧，在帧首部中的目的地址字段填入广播地址，也就是16进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段，数据载荷以及帧尾部，就构成了该广播帧。主机B将该广播帧发送出去，A和C都会收到该广播帧，发现帧首部中的目的地址字段的内容是广播地址，就知道该帧是广播帧，接收该帧，并将该帧交给上层处理。\n多播MAC地址举例：\n简单理解：多播就是给多个目的地发送消息\n随机MAC地址：\n由于可以通过MAC地址查询到用户的精确位置，所以就出现了随机MAC地址\nIP地址 IP地址是TCP/IP体系结构网际层所使用的地址；\nIP地址的作用 IP地址是因特网（Internet）上的主机和路由器所使用的地址，用于标识两部分信息：\n 网络编号：标识因特网上数以百万计的网络 主机编号：标识同意网络上不同主机（或路由器接口）  IP地址具备区分不同网络的功能，如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用。\n数据包转发过程中IP地址与MAC地址的变化情况：\n 数据包转发过程中源IP地址和目的IP地址保持不变； 数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变；  ARP协议 ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址\n","date":"2022-03-13T12:19:27+08:00","image":"https://locter-picture.oss-cn-beijing.aliyuncs.com/cover-900-1.jpg","permalink":"https://Locter9001.github.io/p/network/","title":"计算机网络学习"},{"content":"Linux 安装Go和配置环境，以及gin的安装 一直忘记一些细节，所以写了这个文章。希望能帮到各位，也希望你们不会遇到一些奇奇怪怪的bug\n1. 下载安装Go开发包 和 配置开发环境 1.1 下载Go开发包 首先去Golang官网去复制Linux的下载链接,\n1  官网链接: \u0026#34;https://golang.google.cn/dl/\u0026#34;    这里我会放出来我下载的版本 ( 下载链接 )\n 1  https://golang.google.cn/dl/go1.17.7.linux-amd64.tar.gz   把安装包下载到local目录下:\n 打开local目录的代码如下\n 1  [root@VM-0-7-centos ~]# cd /usr/local/    下载代码\n 1  [root@VM-0-7-centos local]# wget https://golang.google.cn/dl/go1.17.7.linux-amd64.tar.gz   1.2 安装Go开发包  安装Go开发包\n 1  [root@VM-0-7-centos ~]# tar -zxvf go1.17.7.linux-amd64.tar.gz   安装完成后输入ls查看目录里的文件,会多出来一个go目录\n 这里不要着急用 go version 查看版本，因为安装的时候不是全局安装，所以自然看不到\n 1.3 建立工作区 Go的代码必须在工作区内，工作区就是一个目录，包含三个子目录分别是：\n   目录名称 意思     src 里面的每一个子目录，就是一个包，包里包含源代码   pkg 编译后生成的，包的目标文件   bin 生成的可执行文件，Windows是.exe这样的    我们在/home目录下，建立一个目录（文件夹，名字随意只要不是关键字就好），然后在目录里面建立三个子文件夹，也就是上表中所述的。\n1 2 3 4 5 6 7 8 9 10  // 跳转到home目录 [root@VM-0-7-centos ~]# cd /home // 创建工作区（目录） [root@VM-0-7-centos home]# mkdir GoJob // 进入创建的目录！！！ [root@VM-0-7-centos home]# cd GoJob/ // 创建子目录 [root@VM-0-7-centos ChargeCloud]# mkdir pkg [root@VM-0-7-centos ChargeCloud]# mkdir src [root@VM-0-7-centos ChargeCloud]# mkdir bin    输入ls查看创建的文件\n 1.4 配置PATH环境变量 和 设置GOPATH环境变量 使用vim 编辑器打开/etc/profile，这是linux的环境变量设置\n1  [root@VM-0-7-centos ChargeCloud]# vim /etc/profile   打开后按键盘上的[i]键进行编辑 往里加入以下三行代码\n1 2 3  export GOROOT=/usr/local/go\t##Golang安装目录 export PATH=$GOROOT/bin:$PATH export GOPATH=/home/GoJob\t##Golang项目目录   编辑完成后按键盘上的 ESC 然后输入 :wq 保存退出\n 如果你在此过程中失误导致无法退出，可以输入:qa强制退出\n 退出后执行以下命令，使环境变量立即生效（一般情况下要重启生效）\n1  [root@VM-0-7-centos ChargeCloud]# source /etc/profile   之后再输入以下代码查看环境变量配置是否正常\n1  [root@VM-0-7-centos local]# go env   正常情况下会输出如下述注释一样的代码，表示成功\n1 2 3 4  //在我这个方法中，只要你输入以下代码输出版本号就表示成功，因为我们没有全局安装go开发包 [root@VM-0-7-centos local]# go version //我的设备输出： // go version go1.17.7 linux/amd64    如果出现错误，请仔细查看你写的命令行代码！！！ 如果你是刚接触linux的或者go语言的初学者，建议不要直接修改上述代码，切记，心急吃不了热豆腐~\n 2. 下载安装并使用go-gin框架 这里我配上官网的开发文档，我写的再好都不比官网简单明了~ Go-gin 开发文档\n目前好像对go开发包有要求，请确保你的go开发包是 Go 1.13 以上版本\n 如何查看我的go开发包版本？ 在命令行输入：go version 即可\n 下载前说明 在安装之前，有必要说明一下，因为国内特殊的网络环境。我们无法直接访问外网，这就表示也无法从外网下载东西，而Go也是国外公司开发的，下载失败是常有的事情。 下载前需要先改用国内镜像源：\n1 2  [root@VM-0-7-centos local]# export GO111MODULE=on [root@VM-0-7-centos local]# export GOPROXY=https://goproxy.cn    有时候国内镜像源也会失效，这时候去百度搜索golang国内镜像源找一个换就行 搜索的时候，记得从搜索设置里把时间段调成最近一个月的，不然白费力气！\n 还需要注意的是 gin框架安装前需要先创建一个项目！！！！！\n使用如下命令快速跳转到src目录中\n1  [root@VM-0-7-centos ~]# cd $GOPATH/src   创建一个github.com目录（这个你可以研究一下Go的目录结构）并进入里面\n1 2  [root@VM-0-7-centos ~]# mkdir github.com [root@VM-0-7-centos ~]# cd github.com   再次创建一个项目，我在此命名为：myProject（我的项目）并进入里面\n1 2  [root@VM-0-7-centos github.com]# mkdir myProject [root@VM-0-7-centos github.com]# cd myProject   最关键的一步：进到新创建的项目中（myProject），初始化项目\n1  [root@VM-0-7-centos myProject]# go mod init myProject    okay了，现在你可以进行下一步，如果你原本就有项目也可以不执行这一步\n 下载并安装go-gin 1  [root@VM-0-7-centos local]# go get -u github.com/gin-gonic/gin    此时如果你没有出错的话应该是安装完成了 显示服务器回调值为空就去换一个镜像源，可别犯傻给你的设备弄一个梯子，因为服务器用不到你的梯子。如果你是安装到本地的linux中那当我在放屁就行~\n 测试安装的go-gin 新建一个main.go的文件，然后用vim编辑器打开\n1 2  [root@VM-0-7-centos myProject]# touch main.go [root@VM-0-7-centos myProject]# vim main.go   往里面写入以下代码：\n 按 i 键即可进入编辑模式\n 1 2 3 4 5 6 7 8 9 10 11 12 13  package main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 }    按ESC 再输入:wq 保存并退出编辑器\n 执行程序\n1  [root@VM-0-7-centos myProject]#go run main.go   输出以下代码即表示你已经安装成功了\n1 2 3 4 5 6 7 8 9 10 11  [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \u0026#34;debug\u0026#34; mode. Switch to \u0026#34;release\u0026#34; mode in production. - using env:\texport GIN_MODE=release - using code:\tgin.SetMode(gin.ReleaseMode) [GIN-debug] GET /ping --\u0026gt; main.main.func1 (3 handlers) [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Environment variable PORT is undefined. Using port :8080 by default [GIN-debug] Listening and serving HTTP on :8080    很高兴能帮到你~ 如果过程中因为我的教程出现任何问题 请加QQ：3267362309 联系我哟~\n ","date":"2022-03-13T12:14:02+08:00","image":"https://locter-picture.oss-cn-beijing.aliyuncs.com/emmDog.jpg","permalink":"https://Locter9001.github.io/p/golang-%E5%92%8C-gin-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/","title":"Golang 和 Gin 框架的下载安装"},{"content":"Go 语言学习 Go标准库\nGolangStudy\nGo语言项目结构 能一张图片解决我就不多说了\n编写第一个程序 1 2 3 4 5 6 7  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World\u0026#34;) }   编译 在目录编译： 使用CMD打开存放源代码的目录，用命令\n1 2 3  D:\\Go\\src\\testOne\\helloworld\u0026gt; go build D:\\Go\\src\\testOne\\helloworld\u0026gt;helloworld.exe Hello World   进行编译后会生成一个 .exe 文件，在CMD运行就可以输出 Hello World。\n在其他地方编译：\n1  go build 后面写上src以后的文件路径   也就是从 GOPATH/src 后面开始写起\n指定编译之后的 .exe 文件的名字\n1  go build -o hello.exe   go run 像执行脚本文件一样执行Go代码\ngo install go install 分为两部： 1.先编译得到一个可执行文件 2.将可执行文件拷贝到 GOPATH/bin\n跨平台编译（交叉编译） 可以得到能在 Linux MacOs Windows 上运行的可执行文件\n1 2 3  SET CGO_ENABLED=0 //禁用CGO SET GOOS=LINUX //目标平台是Linux SET GOARCH=amd64 //目标处理器架构是amd64位   MacOS 下编译Linux和Windows平台64位可执行程序：\n1 2  CGO_ENABLED=0 GOOS=Linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build   Linux下编译Mac和Windows平台64位可执行程序：\n1 2  CGO_ENABLED=0 GOOS=drawin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build   Windows 下编译Mac平台64位可执行程序：\n1 2 3 4  SET CGO_ENABLED=0 SET GOOS=drawin SET GOARCH=amd64 go build   语法规则 整体语法与C++类似 package main 特点： 函数外面只能写 变量、常量、函数、类型 的声明，不能写语句，如打印某字段之类的\n没有缩进，保存后自动缩进。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //预声明包 main package main //导入语句 类似C++的头文件，导入某段框架 import \u0026#34;fmt\u0026#34; //下面这个字段是非法的，会报错 fmt.Println(\u0026#34;No write this\u0026#34;) //入口函数，与C++的 int main相似 func main(){ fmt.Println(\u0026#34;Hello World\u0026#34;) }   变量与常量 变量 变量声明格式 Go语言的变量声明格式为：\n1 2 3  var 变量名 变量类型 //如： var num int   变量使用特色 Go语言中 非全局变量 声明后必须使用，不使用就编译不过去，这是因为编译时编译器会尽可能的缩小您的代码所占用的空间\n可以使用打印暂时让程序正常编译；%s：占位符 使用num变量替换占位符 1  fmt.Printf(\u0026#34;num:%s\u0026#34;,num)   批量声明 1 2 3 4 5 6  var ( a string b int c bool d float32 )   变量赋值 变量初始化 也就是声明的同时赋值\n1  var nickName string = \u0026#34;罗斯特er\u0026#34;   短变量声明 也就是局部变量的意思,只能在函数体内使用.\n1  age := 19   匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量，匿名变量用一个下划线_表示，列如：\n1 2 3 4 5 6 7 8 9  func foo() (int, string) { return 10,\u0026#34;Q1mi\u0026#34; } func main() { x,_ := foo() _,y := foo() fmt.Println(\u0026#34;X=\u0026#34;, x) //输出 10 \tfmt.Println(\u0026#34;y=\u0026#34;, y) //输出“Q1mi” }   匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。\n常量 不能更改的变量，强制性指定内容，无法更改。 常量初始化\n1  const pi = 3.141596543   也可以批量初始化常量\niota 常量计数器 在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次 如:\n1 2 3 4 5 6  const ( n1 = iota\t//0 \tn2\t//1 \tn3\t//2 \tn4\t//3 )   定义数量级 \u0026lt;\u0026lt; 位运算符,表示在二进制的基础上左移\n1 2 3 4 5 6 7 8 9  const ( _ = iota KB = 1 \u0026lt;\u0026lt; (10 * iota) MB = 1 \u0026lt;\u0026lt; (10 * iota) GB = 1 \u0026lt;\u0026lt; (10 * iota) TB = 1 \u0026lt;\u0026lt; (10 * iota) PB = 1 \u0026lt;\u0026lt; (10 * iota) )   数据类型 Go语言中有丰富的数据类型，除了基本的整形、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（Chanenl）等。Go语言的基本类型和其他语言大同小异。\n基本数据类型 整型 有符号 int （含负数） int8 8位整型（-128~127） int16 16位整型（-32768~32767） int32 32位整型（-2147483646~2147483647） int64 64位整形 （超级大）\n无符号 int （不含负数） uint8 8位整型 uint16 16位整型 uint32 32位整型 uint64 64位整形\n特殊整型 uint 32位操作系统上就是uint32，64位系统上则是uint64 int 32位操作系统上就是int32，64位系统上则是int64 uintptr 无符号整型，用于存放一个指针\n八进制和十六进制 1 2 3 4 5 6 7 8  func main() { //十进制数 \tvar num = 101 fmt.Printf(\u0026#34;%d\\n\u0026#34;,num) fmt.Printf(\u0026#34;%b\\n\u0026#34;,num) //十进制转换二进制 \tfmt.Printf(\u0026#34;%o\\n\u0026#34;,num) //十进制转换八进制 \tfmt.Printf(\u0026#34;%x\\n\u0026#34;,num) //十进制转换十六进制 }   字符串 Go语言中的字符串只能用 双引号(\u0026quot;内容\u0026quot;) 包裹 Go语言中 字符 可以用 单引号('h')包裹 字符串起来就是字符串，字符串分开就是字符。每个字符串可以理解为一个数组\n1 2 3 4 5  text := \u0026#34;Hello World\u0026#34; word := \u0026#39;W\u0026#39; textNum := len(text) // len() 求字符串长度 fmt.Println(text)   数组 数组定义 1  var TorF [2]bool   Go语言中数组长度是数组类型的一部分，不能拿两个不同长度的数组比较\n初始化 方式一 1 2  TorF = [2]bool{true,false} // [true false]   方式二 根据初始值自动推断数组的长度是多少 [...] \u0026lt;= 用这个语法\n1 2  num := [...]int{1,2,3,4,5} // [1 2 3 4 5]   方式三 根据索引来初始化\n1 2  num := [5]int{0:1, 4:5} // [1 0 0 0 5]   多维数组 [ [1, 1] [2, 2] [3, 3] ] 可以当成是一个平面，[x1，y1] ，[x2, y2] 这样的\n定义：\n1  var arr [3][2]int   初始化：\n1 2 3 4 5  arr = [3][2]int{ [2]int{1,1}, [2]int{2,2}, [2]int{3,3} }   if else 分支 1 2 3 4 5 6 7 8  age := 11 if age \u0026gt; 30 { fmt.Println(\u0026#34;中年人\u0026#34;) } else if age \u0026lt; 30 \u0026amp;\u0026amp; age \u0026gt; 18 { fmt.Printls(\u0026#34;青年\u0026#34;) } else { fmt.Println(\u0026#34;未成年\u0026#34;) }   还可以用 if 判断内声明变量法，作用域知识，age 在外部为 undifind\n1 2 3 4 5 6 7  if age:= 30; age \u0026gt; 30 { fmt.Println(\u0026#34;中年人\u0026#34;) } else if age \u0026lt; 30 \u0026amp;\u0026amp; age \u0026gt; 18 { fmt.Printls(\u0026#34;青年\u0026#34;) } else { fmt.Println(\u0026#34;未成年\u0026#34;) }   for 循环 在 Go 语言中只有一个循环，就是 for 循环，但是他有很多变种。\n基本格式 1 2 3  for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) }   外部声明变量法 1 2 3 4 5 6 7 8 9  var i = 5 for ; i \u0026lt; 10; i++ { fmt.Println(i) } //变种 for i \u0026lt; 10 { fmt.Println(i) i++ }   五限循环法 for 循环可以通过 break、return、panic 语句强制退出\n1 2 3  for { fmt.Println(\u0026#34;输出\u0026#34;) }   for range 键值循环 Go语言中可以使用 for range 便利数组、切片、字符串、map及通道（channel）。通过 for range 遍历的返回值有以下规律： 1.数组、切片、字符串返回索引和值。 2.map返回键和值。 3.通道（channel）只返回通道内的值。\n1 2 3 4  s := \u0026#34;Hello World\u0026#34; for i, v := range s { fmt.Printf(\u0026#34;%d %c\\n\u0026#34;, i, v) }   switch 1 2 3 4 5 6 7 8 9 10  n := 3 switch n { case 1: fmt.Println(\u0026#34;1\u0026#34;) case n \u0026gt; 2: fmt.Println(\u0026#34;n大于2\u0026#34;) default: fmt.Println(\u0026#34;无效数字\u0026#34;) } // 输出“n大于2”   另外 fallthrough 语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的\n1 2 3 4 5 6 7 8 9 10 11  n := 1 switch n { case 1: fmt.Println(\u0026#34;1\u0026#34;) fallthrough case n \u0026gt; 2: fmt.Println(\u0026#34;n大于2\u0026#34;) default: fmt.Println(\u0026#34;无效数字\u0026#34;) } // 输出 “1” 和 “n大于2”   goto 跳到某一行 1 2 3 4 5  goto next fmt.Println(\u0026#34;第一个输出\u0026#34;) next: fmt.Println(\u0026#34;第二个输出\u0026#34;) // 输出 “第二个输出” 第一个不输出   切片（slice） 切片是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。切片是一个引用类型，它的内部结构包括 地址、长度、容量。切片一般用于快速地操作一块数据集合。\n1 2 3 4 5 6 7  func main() { s := [...]int{0,1,2,3,4,5,6,7,8,9} TheSlice1 := s[0:4] //这是一个切片 到数组第4位就停 不输出第四位 第一位输出  TheSlice2 := s[2:6] fmt.Println(TheSlice1,TheSlice2) //输出 [0 1 2 3] [2 3 4 5] 这里就没有4和6 }   二次切片 切片的容量是与引用数组的容量的相同 切片也可以引用切片,修改底层引用数组的长度和内容时后面的也会跟着变\nmake函数创造切片 1  arr := make([]类型,长度,容量)   为切片增加元素 1 2 3 4 5 6 7  s := []int{0,1,2,3,4,5,6,7,8,9} TheSlice1 := s[0:4] TheSlice1[10] = 10 //注意,不能这么写  // 调用append函数必须用原来的切片变量接收返回值 theSlicel = append(theSlicel,10) fmt.Println(TheSlice1) //输出 [0 1 2 3 10]   copy函数 Go语言内建的 copy() 函数可以迅速的将一个切片的数据复制到另外一个切片空间中 使用方式如下:\n1  copy(destSlice, srcSlice []T)    srcSlice : 数据来源切片 destSlice : 目标切片 T数据类型  指针 pointer Go中支持指针，但不支持指针运算，也就是说只有取值,和取地址\n \u0026amp; ： 取地址 * ： 根据地址取值  1 2 3 4 5  p := 1010 ThePoint := \u0026amp;p fmt.Println(ThePoint)//输出地址 0xc00000a0a8 \tpValue := *ThePoint fmt.Println(pValue)//根据地址取值 输出1010   make和new的区别  make和new都是用来申请内存的 new很少用，一般用来给基本数据类型申请内存，string、int返回的是对应类型的指针（*String、*int）。 make是用来给 slice、map、chan 申请内存的，make函数返回的是对应的这三个类型本身。  map map是一种无序的基于 key-value 的数据结构，Go语言中的map是引用类型，必须初始化才能使用。\nmap定义 Go语言中 map 的定义语法如下：\n1  map[keyType]ValueType    keyType表示键的类型。 ValueType表示键对应的值的类型  1 2 3 4 5 6 7 8 9 10 11  func main() { var m1 map[string]int fmt.Println(m1 == nil) m1 = make(map[string]int,10) m1[\u0026#34;穷\u0026#34;] = 18 m1[\u0026#34;丑\u0026#34;] = 35 fmt.Println(m1) fmt.Println(m1[\u0026#34;穷\u0026#34;]) }   类似对象的操作，输入口令提取对应的东西\nmap的遍历 1 2 3 4 5 6 7 8 9 10 11 12  fmt.Println(\u0026#34;方式一\u0026#34;) for k,v := range m1 { fmt.Println(k,v) } fmt.Println(\u0026#34;方式二\u0026#34;) for k := range m1 { fmt.Println(k) } fmt.Println(\u0026#34;方式三\u0026#34;) for _, v := range m1 { fmt.Println(v) }   删除 1 2 3  fmt.Println(\u0026#34;删除\u0026#34;) delete(m1,\u0026#34;丑\u0026#34;) fmt.Println(m1)   函数 函数的定义\n1  func sum(参数) (返回值) {}   函数的使用\n1 2 3 4 5 6 7  func sum(x int, y int) (ret int) { return x + y } func main() { r := sum(2,3) fmt.Println(r) }   多个返回值 1 2 3 4 5 6 7  func sum() (int，string) { return 100, \u0026#34;元\u0026#34; } func main() { _, r := sum(2,3) fmt.Println(r) }   可变长度的参数 1 2 3 4 5 6 7  func fun(x int, y ...int) (ret int) { fmt.Println(x) fmt.Println(y) // y的类型是切片 []int } func main() { fun(1,2,3,4,5,6,7,8,9) }   无名称函数 函数内部没有办法声明有名字的函数，所以我们创建一个没有名字的函数，用变量去接收它\n1 2 3 4 5 6 7 8  func main() { fun1 := func(x, y int){ fmt.Println(x + y) return } fun1(2,3) }   Go语言中没有默认参数\n闭包 闭包也是一个函数，但是这个函数包含了他外部作用域的一个或多个变量。 底层原理：\n 函数可以作为返回值 函数内部查找变量的顺序，现在自己内部找，找不到再去外层找。  1 2 3 4 5 6 7 8 9 10 11 12  func main() { ret := adder(100) ret2 := ret(200) fmt.Println(ret2) } func adder(x int) func(int) int { return func(y int) int { x += y return x } } //输出 300   defer 最先 被定义defer的变量或者函数 最后执行\n内置函数介绍 内置函数|介绍\n | \u0026mdash; close|主要用来关闭channel len|用来求长度，比如string、array、slice、map、channel。 new|用来分配内存，主要用来分配值类型，比如int、string。返回的是指针 make|用来分配内存，主要引用类型，比如chan、map、slice append|用来追加元素到数组、slice中 panic和recover|用来做错误处理  panic / recover 使用 panic/recover 模式来处理错误。panic 可以在任何地方引发，但是 recover 只有在 defer 调用的函数中有效。\n自定义类型和类型别名 自定义类型 type 关键字用来定义自定义类型变量\n1 2 3 4  type myInt int //自定义int类型变量 var m = myInt m = 100 fmt.Println(m)   类型别名 某个类型的其他称呼，类似你int32类型变量 可以称为rune类型变量，rune的类型实际上就是int32类型，\n1 2 3 4  type yourInt = int var m yourInt m = 100 fmt.Println(m)   自定义类型和类型别名的区别 可以理解为一个是新建，而另一个是在原有的基础上复制一个类型。\n结构体struct 结构体是由不同类型变量组成的一个集合体 比如我用结构体造了一个标准人类的类型变量，里面包含这个人的年龄、姓名、性别这类属性。\n1 2 3 4 5 6 7 8 9 10  type person struct { name string age int gender string } var locter person locter.name = \u0026#34;locter\u0026#34; locter.age = 20 locter.gender = \u0026#34;男\u0026#34;   匿名结构体 多用于临时场景\n1 2 3 4 5 6 7  var s struct { x string y int } s.x = \u0026#34;hallo\u0026#34; s.y = 100   结构体指针 如果想在某个函数中修改结构体内的数据，就需要用到结构体指针。因为按常理在Go语言中函数的参数传参永远是拷贝粘贴的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  type person struct { name string age int gender string } func f(x person) { x.gender = \u0026#34;男\u0026#34; } func f2(x *person) { //接收指针类型的person  (*x).gender = \u0026#34;男\u0026#34; //这里修改的是地址中的属性，即 a 的属性 } func main() { var a paerson a.name = \u0026#34;王莉娜\u0026#34; a.gender = \u0026#34;女\u0026#34; f(a) // 这一行是无效的，并不能真正的去改变a的属性，因为函数传参是拷贝粘贴，改变的是a的副本  fmt.Println(a.gender) //女  f2(\u0026amp;a) //这里传过去的是a的地址 }   创建指针类型结构体 可以用 new 关键字来为结构体开辟一个内存地址\n1 2 3 4 5 6  func main() { var p2 = new(person) fmt.Printf(\u0026#34;%T\\n\u0026#34;, p2) //输出 *main.person  fmt.Printf(p2) //输出 \u0026amp;{ }  fmt.Printf(\u0026#34;%p\\n\u0026#34;, p2) //输出p2变量的内存地址 }   匿名字段结构体 字段比较少也比较简单的场景，不常使用的方法 列如下面这类，没有对结构体内的数值进行命名\n1 2 3 4  type person struct { string int }   如何使用未命名字段？\n1 2 3 4 5 6 7 8  func main() { p1 := person { \u0026#34;张三\u0026#34;, 9000, } fmt.Println(p1) fmt.Println(p1.string)//可以使用类型来选择字段 }   嵌套结构体 在一个结构体中嵌套另一个结构体，这样做的好处是不用反复的写同样的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  //结构体嵌套 type address struct { province string city string } type person struct { name string age int addr address } type company struct { name string addr address } func main() { p1 := person{ name : \u0026#34;张三\u0026#34;, age : 19, addr: address{ province: \u0026#34;广西\u0026#34;, city: \u0026#34;长沙\u0026#34;, }, } fmt.Println(p1) fmt.Println(p1.addr.city) }   匿名嵌套结构体 优点是可以不用对嵌套的结构体命名，还可以直接访问嵌套的结构体的数据，不需要进行二次进入内部然后访问，大多数时候会用到这个方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  //匿名嵌套结构体 type address struct { province string city string } type person struct { name string age int address } func main() { p1 := person{ name : \u0026#34;张三\u0026#34;, age : 19, address: address{ province: \u0026#34;广西\u0026#34;, city: \u0026#34;长沙\u0026#34;, }, } fmt.Println(p1) fmt.Println(p1.city)//不需要 p1.address.city }   可以使用嵌套结构体来模拟实现继承，Go语言中本没有继承\n结构体与JSON 在这里需要用到json包！！！ 1.序列化： 把Go语言中的结构体变量 =\u0026gt; Json格式的字符串 2.反序列化： Json格式的字符串 =\u0026gt; Go语言中能够识别的结构体变量\n序列化： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) // 结构体与JSON  type person struct { Name string Age int } func main() { p1 := person{ Name: \u0026#34;张三\u0026#34;, Age: 22, } b, err := json.Marshal(p1) if err != nil { fmt.Printf(\u0026#34;Marshal failed err:%v\u0026#34;, err) return } fmt.Println(string(b)) } //最终输出：{\u0026#34;Name\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;Age\u0026#34;:22}   反序列化： 1 2 3 4 5 6 7 8 9 10  str := `{\u0026#34;Name\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;Age\u0026#34;:22}` var p2 person _err := json.Unmarshal([]byte(str), \u0026amp;p2) if _err != nil { fmt.Printf(\u0026#34;Marshal failed err:%v\u0026#34;, _err) return } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, p2) //最终输出：main.person{Name:\u0026#34;张三\u0026#34;, Age:22}   方法和接收者 Go语言中的 方法（Method） 是一种作用于特定类型变量的函数。这种特定类型变量叫做 接收者（Receiver）。接受者的概念就类似于其它语言中的 this 或者 self。\n方法的定义格式如下：\n1 2 3  func (接受者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 }   列如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  type dog struct { name string } //构造函数 func newDog(name string) dog { return dog { name: name, } } //方法和接收者 func (d dog) wang() { fmt.Printf(\u0026#34;%s : 汪汪汪~\u0026#34;, d.name) } func main() { d1 := newDog(\u0026#34;汪柴\u0026#34;) d1.wang() //输出 “汪柴 : 汪汪汪~” }   接口（interface） 接口是一种类型，是一种特殊的类型，它规定了变量有哪些方法。 （你把东西传进去，不管什么类型他都能运行，类似print方法）\n在编程中会遇到以下场景：\n 我不关心一个变量是什么类型，我只关心能调用它的什么方法  接口也可以嵌套\n接口的定义与实现 1 2 3 4  type 接口名 interface { 方法名1(参数1， 参数2...)(返回值1， 返回值2...) 方法名2(参数1， 参数2...)(返回值1， 返回值2...) }   用来给变量\\参数\\返回值等设置类型。\n接口的实现 一个变量如果实现了接口中规定的所有的方法，那么这个变量就实现了这个接口，可以称为这个接口类型的变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  type cat struct {} type dog struct {} type person struct {} //定义一个能叫的类型，使用关键字interface type speaker interface { speak() //只要实现了speak方法的变量都是speaker类型 } func (c cat) speak() { fmt.Println(\u0026#34;喵喵喵~\u0026#34;) } func (d dog) speak() { fmt.Println(\u0026#34;旺旺旺~\u0026#34;) } func (p person) speak() { fmt.Println(\u0026#34;啊啊啊~\u0026#34;) } //在原本的方法中，传递参数只能有一种类型，而我们要传的是三种不同类型 //分别是 cat dog person 这在一般情况下是不允许的 //但是我们可以定义一个可以传进去的类型，speaker 他是interface（接口）类型 //在其中调用speak函数 func da(x speaker) { x.speak() } func main() { var c1 cat var d1 dog var p1 person da(c1) da(d1) da(p1) }   值接收者和指针接收者的区别 使用值接收者实现接口，结构体类型和结构体指针类型的变量都能存。 指针接收者实现接口只能接收指针类型的变量，无法接收值类型变量。\n接口和类型的关系 多个类型可以实现同一个接口。 一个类型可以实现多个接口。\n空接口 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。 空接口类型的变量可以存储任意类型的变量。\n1  interface {}   空接口没有必要起名字 所有的类型都实现了空接口，也就是任意类型的变量都能保存到空接口中。\n1 2 3 4 5 6 7 8 9 10  func main() { var m1 map[string]interface{} m1 = make(map[string]interface{}, 16) m1[\u0026#34;name\u0026#34;] = \u0026#34;张三\u0026#34; m1[\u0026#34;age\u0026#34;] = 18 m1[\u0026#34;married\u0026#34;] = true m1[\u0026#34;hobby\u0026#34;] = [...]string{\u0026#34;唱\u0026#34;,\u0026#34;跳\u0026#34;,\u0026#34;rap\u0026#34;} fmt.Println(m1) } // 输出： map[age:18 hobby:[唱 跳 rap] married:true name:张三]   空接口参数使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func show(a interface{}) { fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, a, a) } func main() { var m1 map[string]interface{} m1 = make(map[string]interface{}, 16) m1[\u0026#34;name\u0026#34;] = \u0026#34;张三\u0026#34; m1[\u0026#34;age\u0026#34;] = 18 m1[\u0026#34;married\u0026#34;] = true m1[\u0026#34;hobby\u0026#34;] = [...]string{\u0026#34;唱\u0026#34;,\u0026#34;跳\u0026#34;,\u0026#34;rap\u0026#34;} show(m1) show(false) show(nil) } //输出： //type:map[string]interface {} value:map[age:18 hobby:[唱 跳 rap] married:true name:张三]  //type:bool value:false  //type:\u0026lt;nil\u0026gt; value:\u0026lt;nil\u0026gt;    类型断言 空接口可以储存任意类型的值，那我们如何获取其储存的具体数据呢？\n想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：\n1  x.(T)   其中：\n x: 表示类型为interface{}的变量; T: 表示断言 x可能是的类型;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func show(a interface{}) { fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, a, a) switch t := a.(type) { case int: fmt.Println(\u0026#34;is int: \u0026#34;,t) case string: fmt.Println(\u0026#34;is string: \u0026#34;,t) case bool: fmt.Println(\u0026#34;is bool: \u0026#34;,t) } } func main() { show(\u0026#34;hello\u0026#34;) } // 输出： // type:string value:hello // is string: hello   包（package） 包介绍 包（package） 十多个Go源码的集合，是一种高级的代码复用方案。Go语言为我们提供了很多内置包，如：fmt、os、io等\n定义包 我们还可以根据自己的需要创建自己的包，一个包可以简单理解为一个存放.go文件的文件夹。该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包\n1  package 包名   注意事项：\n 一个文件夹下面只能有一个包，同样一个包的文件不能再多个文件夹下。 包名可以不和文件夹的名字一样，包名不包含 -符号。 包名为main的包为应用程序的入口包，编译时不包含main包的源代码时不会得到可执行文件。  使用包 要注意的事！包中的标识符（变量名/函数名/结构体/接口等）如果首字母时小写的，表示私有（只能在当前这个包中使用），如果想要在其他包中使用，需要将首字母改成大写。\n包的路径可以写相对路径，在使用 import 导入包时，不需要填写绝对位置，就比如我要导入 calc 文件夹中的 hello.go 时不需要写成如下格式：\n1 2 3 4 5  //错误方式 import \u0026#34;../calc/hello.go\u0026#34; //正确方式 import \u0026#34;../calc\u0026#34;   你只需要指定它的目录即可，此处的../表示返回上一级目录\nGo语言中禁止循环导入包！！！\n文件操作 首先导入os包，对于文件操作多数时候都需要使用到os包，如下：\n1  import \u0026#34;os\u0026#34;   打开文件 os.Open() 函数能够打开一个文件，返回一个 *File 和一个 err\n关闭文件 对得到的文件实例调用Close()方法能够关闭文件。\n读取文件 file.Read() 1  func (f *File) Read(b []byte) (n int, err error)   它接受一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时返回0和io.EOF\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  D:\\Go\\src\\FileOperation\u0026gt;go run File.go 读了128个字节 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fileObj, err := os.Open(\u0026#34;./File.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;Unabl 读了128个字节 e to open this file: \u0026#34;, err) return } // 关闭文件 defer fileObj.Close() // 读文件 // var tmp = make([]byte, 128) / 读了128个字节 /指定读的长度 var tmp [128]byte for { n, err := fileObj.Read(tmp[:]) if err != nil { fmt.Printf(\u0026#34;read from file f 读了128个字节 ailed,err:%v\u0026#34;, err) return } fmt.Printf(\u0026#34;读了%d个字节\\n\u0026#34;, n) fmt.Println(string(tmp[:n])) if n \u0026lt; 128 { return 读了10个字节 } } }   文件写入操作 os.OpenFile() 函数能够以指定模式打开文件，从而实现文件写入相关功能。\n1 2 3 4  func OpenFile(name string, flag int, perm FileMode) (*File, error) { }   其中，name：要打开文件的文件名，flag ：打开文件的模式，有以下几种：\n   模式 含义     os.O_WRONLY 只写   os.O_CREATE 创建文件   os.O_RDONLY 只读   os.O_RDWR 读写   os.O_TRUNC 清空   os.O_APPEND 追加    perm ： 文件权限，一个八进制数。r（读）o4、w（写）o2、x （执行）o1。\n练习：制作一个日志记录程序 接口：用处？日志可以输出到终端，也可以输出到文件，输出到kafka\n文件操作：\n需求分析  支持往不同的地方输出日志 日志分级别  Debug Trace Info Warning Error Fatal   日志要支持开关控制，开发阶段都可以使用，上线后只有INFO级别以下才能使用。 完整的日志记录要包含有时间、行号、文件名、日志级别、日志信息 日志文件要切割  ","date":"2022-03-13T12:12:38+08:00","image":"https://locter-picture.oss-cn-beijing.aliyuncs.com/Go-Top.jpg","permalink":"https://Locter9001.github.io/p/go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/","title":"Go 语言学习（基础）"}]